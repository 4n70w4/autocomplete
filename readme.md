** Задача **

Нужен поиск по таблице с автодополнением ввода. Автодополнение должно работать, начиная с 1-ого введённого символа, с минимальными задержками между вводом символов и появлние подсказок (<70мс). Нагрузка - 500 RPS к сервису
автоподсказок.


** Решение **

Простейший пример решения и синтетические тесты в течении 90 секунд (ab -s 1 -n 1500000 -c 200) при 200 одновременных запросах.

CREATE TABLE `dictionary` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(40) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `txt` (`name`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

Либо

CREATE TABLE `dictionary` (
  `name` varchar(40) NOT NULL,
  PRIMARY KEY (`name`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

Запросы вида SELECT name FROM dictionary WHERE name LIKE '{$query}%' LIMIT 15;

Что вполне удовлетворяет требованию 500 RPS <70мс на сервере 8 x Intel(R) Core(TM) i7-4770 CPU @ 3.40GHz (1 Socket); 2x HDD 2,0 TB; 4x RAM 8192 MB.

Около 12 000 запросов в секунду при времени отклика 27мс в 99% запросов и 13мс в 95%. Загрузка CPU в пике 65%

Конфиги nginx, php-fpm и mariadb не оптимизированы под данный профиль нагрузки, были скопированы от другого приложения.

Кеширование результатов SQL запросов в apcu позволит увеличить количество запросов до 15 тысяч в секунду, а время отклика уменьшается до 21мс 99% запросов и 19мс 95%. Загрузка CPU до 35%.

При снижении количества конкурентых запросов до 100 - время отклика улучшается примерно в 2 раза.

Доолнительное кеширование на стороне nginx увеличивает число запросов до 16.5к в секунду, что утилизирует сеть 100 Мбит/с практически на 100%, время отклика повышается до 17мс у 99% запросов, потребление CPU 10%.

При снижении количества конкурентых запросов до 100 - время отклика улучшается примерно в 4 раза.

В следующих итерациях можно улучшить качетсво автоподсказок, например, ранжированием результата, применением фонетических алгоритов, учётом опечаток и синонимов, или переходом на sphinx или elastic search. Также можно написать сервис на Go Lang реализующий алгоритм префиксного дерева (Trie), использование этого алгоритма на PHP не даёт какого-либо значительного профита. Также можно рассмотреть возможность использования Redis в качестве хранилища для словаря.